digraph "" {
AccessControl -> Context [ label="1" ];
AccessControl -> IAccessControl [ label="2" ];
AccessControl -> ERC165 [ label="3" ];
AccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getRoleAdmin(bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    grantRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    revokeRole(bytes32,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    renounceRole(bytes32,address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkRole(bytes32)</TD></TR><TR><TD align="left">    _checkRole(bytes32,address)</TD></TR><TR><TD align="left">    _setupRole(bytes32,address)</TD></TR><TR><TD align="left">    _setRoleAdmin(bytes32,bytes32)</TD></TR><TR><TD align="left">    _grantRole(bytes32,address)</TD></TR><TR><TD align="left">    _revokeRole(bytes32,address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    DEFAULT_ADMIN_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _roles</TD></TR></TABLE> >];

IAccessControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IAccessControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    hasRole(bytes32,address)</TD></TR><TR><TD align="left">    getRoleAdmin(bytes32)</TD></TR><TR><TD align="left">    grantRole(bytes32,address)</TD></TR><TR><TD align="left">    revokeRole(bytes32,address)</TD></TR><TR><TD align="left">    renounceRole(bytes32,address)</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkOwner()</TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

Governor -> Context [ label="1" ];
Governor -> ERC165 [ label="2" ];
Governor -> EIP712 [ label="3" ];
Governor -> IGovernor [ label="4" ];
Governor -> IERC721Receiver [ label="5" ];
Governor -> IERC1155Receiver [ label="6" ];
Governor[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Governor</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    version()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hashProposal(address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    state(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    proposalSnapshot(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    proposalDeadline(uint256)</font></TD></TR><TR><TD align="left">    proposalThreshold()</TD></TR><TR><TD align="left"><font color="#FFA500">    propose(address[],uint256[],bytes[],string)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    execute(address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getVotes(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getVotesWithParams(address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    castVote(uint256,uint8)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    castVoteWithReason(uint256,uint8,string)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    castVoteWithReasonAndParams(uint256,uint8,string,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32)</font></TD></TR><TR><TD align="left">    relay(address,uint256,bytes)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _quorumReached(uint256)</TD></TR><TR><TD align="left">    _voteSucceeded(uint256)</TD></TR><TR><TD align="left">    _getVotes(address,uint256,bytes)</TD></TR><TR><TD align="left">    _countVote(uint256,address,uint8,uint256,bytes)</TD></TR><TR><TD align="left">    _defaultParams()</TD></TR><TR><TD align="left">    _execute(uint256,address[],uint256[],bytes[],bytes32)</TD></TR><TR><TD align="left">    _beforeExecute(uint256,address[],uint256[],bytes[],bytes32)</TD></TR><TR><TD align="left">    _afterExecute(uint256,address[],uint256[],bytes[],bytes32)</TD></TR><TR><TD align="left">    _cancel(address[],uint256[],bytes[],bytes32)</TD></TR><TR><TD align="left">    _castVote(uint256,address,uint8,string)</TD></TR><TR><TD align="left">    _castVote(uint256,address,uint8,string,bytes)</TD></TR><TR><TD align="left">    _executor()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyGovernance()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    BALLOT_TYPEHASH</TD></TR><TR><TD align="left">    EXTENDED_BALLOT_TYPEHASH</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _proposals</TD></TR><TR><TD align="left">    _governanceCall</TD></TR></TABLE> >];

IGovernor -> IERC165;
IGovernor[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IGovernor</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    version()</TD></TR><TR><TD align="left">    COUNTING_MODE()</TD></TR><TR><TD align="left">    hashProposal(address[],uint256[],bytes[],bytes32)</TD></TR><TR><TD align="left">    state(uint256)</TD></TR><TR><TD align="left">    proposalSnapshot(uint256)</TD></TR><TR><TD align="left">    proposalDeadline(uint256)</TD></TR><TR><TD align="left">    votingDelay()</TD></TR><TR><TD align="left">    votingPeriod()</TD></TR><TR><TD align="left">    quorum(uint256)</TD></TR><TR><TD align="left">    getVotes(address,uint256)</TD></TR><TR><TD align="left">    getVotesWithParams(address,uint256,bytes)</TD></TR><TR><TD align="left">    hasVoted(uint256,address)</TD></TR><TR><TD align="left">    propose(address[],uint256[],bytes[],string)</TD></TR><TR><TD align="left">    execute(address[],uint256[],bytes[],bytes32)</TD></TR><TR><TD align="left">    castVote(uint256,uint8)</TD></TR><TR><TD align="left">    castVoteWithReason(uint256,uint8,string)</TD></TR><TR><TD align="left">    castVoteWithReasonAndParams(uint256,uint8,string,bytes)</TD></TR><TR><TD align="left">    castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32)</TD></TR></TABLE> >];

TimelockController -> AccessControl [ label="1" ];
TimelockController -> IERC721Receiver [ label="2" ];
TimelockController -> IERC1155Receiver [ label="3" ];
TimelockController[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TimelockController</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left">    isOperation(bytes32)</TD></TR><TR><TD align="left">    isOperationPending(bytes32)</TD></TR><TR><TD align="left">    isOperationReady(bytes32)</TD></TR><TR><TD align="left">    isOperationDone(bytes32)</TD></TR><TR><TD align="left">    getTimestamp(bytes32)</TD></TR><TR><TD align="left">    getMinDelay()</TD></TR><TR><TD align="left">    hashOperation(address,uint256,bytes,bytes32,bytes32)</TD></TR><TR><TD align="left">    hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)</TD></TR><TR><TD align="left">    schedule(address,uint256,bytes,bytes32,bytes32,uint256)</TD></TR><TR><TD align="left">    scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)</TD></TR><TR><TD align="left">    cancel(bytes32)</TD></TR><TR><TD align="left">    execute(address,uint256,bytes,bytes32,bytes32)</TD></TR><TR><TD align="left">    executeBatch(address[],uint256[],bytes[],bytes32,bytes32)</TD></TR><TR><TD align="left">    updateDelay(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    onERC721Received(address,address,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155Received(address,address,uint256,uint256,bytes)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _schedule(bytes32,uint256)</TD></TR><TR><TD align="left">    _execute(address,uint256,bytes)</TD></TR><TR><TD align="left">    _beforeCall(bytes32,bytes32)</TD></TR><TR><TD align="left">    _afterCall(bytes32)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyRoleOrOpenRole(bytes32)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    TIMELOCK_ADMIN_ROLE</TD></TR><TR><TD align="left">    PROPOSER_ROLE</TD></TR><TR><TD align="left">    EXECUTOR_ROLE</TD></TR><TR><TD align="left">    CANCELLER_ROLE</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _DONE_TIMESTAMP</TD></TR><TR><TD align="left">    _timestamps</TD></TR><TR><TD align="left">    _minDelay</TD></TR></TABLE> >];

GovernorCountingSimple -> Governor;
GovernorCountingSimple[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernorCountingSimple</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    COUNTING_MODE()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    hasVoted(uint256,address)</font></TD></TR><TR><TD align="left">    proposalVotes(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _quorumReached(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _voteSucceeded(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _countVote(uint256,address,uint8,uint256,bytes)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _proposalVotes</TD></TR></TABLE> >];

GovernorSettings -> Governor;
GovernorSettings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernorSettings</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    votingDelay()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    votingPeriod()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    proposalThreshold()</font></TD></TR><TR><TD align="left">    setVotingDelay(uint256)</TD></TR><TR><TD align="left">    setVotingPeriod(uint256)</TD></TR><TR><TD align="left">    setProposalThreshold(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setVotingDelay(uint256)</TD></TR><TR><TD align="left">    _setVotingPeriod(uint256)</TD></TR><TR><TD align="left">    _setProposalThreshold(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _votingDelay</TD></TR><TR><TD align="left">    _votingPeriod</TD></TR><TR><TD align="left">    _proposalThreshold</TD></TR></TABLE> >];

GovernorTimelockControl -> IGovernorTimelock [ label="1" ];
GovernorTimelockControl -> Governor [ label="2" ];
GovernorTimelockControl[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernorTimelockControl</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    state(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    timelock()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    proposalEta(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    queue(address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left">    updateTimelock(TimelockController)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _execute(uint256,address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _cancel(address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _executor()</font></TD></TR><TR><TD align="left">    _updateTimelock(TimelockController)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _timelock<font color="blue" POINT-SIZE="10"> (TimelockController)</font></TD></TR><TR><TD align="left">    _timelockIds</TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'name()' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'version()' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'hashProposal(address[],uint256[],bytes[],bytes32)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'proposalSnapshot(uint256)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'proposalDeadline(uint256)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'getVotes(address,uint256)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'getVotesWithParams(address,uint256,bytes)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'propose(address[],uint256[],bytes[],string)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'execute(address[],uint256[],bytes[],bytes32)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'castVote(uint256,uint8)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'castVoteWithReason(uint256,uint8,string)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'castVoteWithReasonAndParams(uint256,uint8,string,bytes)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)' collides in inherited contracts IGovernor, Governor where Governor is chosen.<BR/>'castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32)' collides in inherited contracts IGovernor, Governor where Governor is chosen.</font></TD></TR></TABLE> >];

GovernorVotes -> Governor;
GovernorVotes[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernorVotes</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _getVotes(address,uint256,bytes)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    token<font color="blue" POINT-SIZE="10"> (IVotes)</font></TD></TR></TABLE> >];

GovernorVotesQuorumFraction -> GovernorVotes;
GovernorVotesQuorumFraction[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernorVotesQuorumFraction</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    quorumNumerator()</TD></TR><TR><TD align="left">    quorumNumerator(uint256)</TD></TR><TR><TD align="left">    quorumDenominator()</TD></TR><TR><TD align="left"><font color="#FFA500">    quorum(uint256)</font></TD></TR><TR><TD align="left">    updateQuorumNumerator(uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _updateQuorumNumerator(uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _quorumNumerator</TD></TR><TR><TD align="left">    _quorumNumeratorHistory</TD></TR></TABLE> >];

IGovernorTimelock -> IGovernor;
IGovernorTimelock[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IGovernorTimelock</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    timelock()</TD></TR><TR><TD align="left">    proposalEta(uint256)</TD></TR><TR><TD align="left">    queue(address[],uint256[],bytes[],bytes32)</TD></TR></TABLE> >];

IVotes[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IVotes</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    getVotes(address)</TD></TR><TR><TD align="left">    getPastVotes(address,uint256)</TD></TR><TR><TD align="left">    getPastTotalSupply(uint256)</TD></TR><TR><TD align="left">    delegates(address)</TD></TR><TR><TD align="left">    delegate(address)</TD></TR><TR><TD align="left">    delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)</TD></TR></TABLE> >];

IERC1155Receiver -> IERC165;
IERC1155Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1155Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC1155Received(address,address,uint256,uint256,bytes)</TD></TR><TR><TD align="left">    onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)</TD></TR></TABLE> >];

ERC20 -> Context [ label="1" ];
ERC20 -> IERC20 [ label="2" ];
ERC20 -> IERC20Metadata [ label="3" ];
ERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    name()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    symbol()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    decimals()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    totalSupply()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    balanceOf(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transfer(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    allowance(address,address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    approve(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    transferFrom(address,address,uint256)</font></TD></TR><TR><TD align="left">    increaseAllowance(address,uint256)</TD></TR><TR><TD align="left">    decreaseAllowance(address,uint256)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transfer(address,address,uint256)</TD></TR><TR><TD align="left">    _mint(address,uint256)</TD></TR><TR><TD align="left">    _burn(address,uint256)</TD></TR><TR><TD align="left">    _approve(address,address,uint256)</TD></TR><TR><TD align="left">    _spendAllowance(address,address,uint256)</TD></TR><TR><TD align="left">    _beforeTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left">    _afterTokenTransfer(address,address,uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _balances</TD></TR><TR><TD align="left">    _allowances</TD></TR><TR><TD align="left">    _totalSupply</TD></TR><TR><TD align="left">    _name</TD></TR><TR><TD align="left">    _symbol</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

ERC20Votes -> IVotes [ label="1" ];
ERC20Votes -> ERC20Permit [ label="2" ];
ERC20Votes[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Votes</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    checkpoints(address,uint32)</TD></TR><TR><TD align="left">    numCheckpoints(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    delegates(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getVotes(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getPastVotes(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getPastTotalSupply(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    delegate(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _checkpointsLookup(ERC20Votes.Checkpoint[],uint256)</TD></TR><TR><TD align="left">    _maxSupply()</TD></TR><TR><TD align="left"><font color="#FFA500">    _mint(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _burn(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _afterTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left">    _delegate(address,address)</TD></TR><TR><TD align="left">    _moveVotingPower(address,address,uint256)</TD></TR><TR><TD align="left">    _writeCheckpoint(ERC20Votes.Checkpoint[],function(uint256,uint256) returns(uint256),uint256)</TD></TR><TR><TD align="left">    _add(uint256,uint256)</TD></TR><TR><TD align="left">    _subtract(uint256,uint256)</TD></TR><TR><TD align="left">    _unsafeAccess(ERC20Votes.Checkpoint[],uint256)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _DELEGATION_TYPEHASH</TD></TR><TR><TD align="left">    _delegates</TD></TR><TR><TD align="left">    _checkpoints</TD></TR><TR><TD align="left">    _totalSupplyCheckpoints</TD></TR></TABLE> >];

IERC20Metadata -> IERC20;
IERC20Metadata[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20Metadata</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    name()</TD></TR><TR><TD align="left">    symbol()</TD></TR><TR><TD align="left">    decimals()</TD></TR></TABLE> >];

ERC20Permit -> ERC20 [ label="1" ];
ERC20Permit -> IERC20Permit [ label="2" ];
ERC20Permit -> EIP712 [ label="3" ];
ERC20Permit[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC20Permit</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    permit(address,address,uint256,uint256,uint8,bytes32,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    nonces(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    DOMAIN_SEPARATOR()</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _useNonce(address)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _nonces</TD></TR><TR><TD align="left">    _PERMIT_TYPEHASH</TD></TR><TR><TD align="left">    _PERMIT_TYPEHASH_DEPRECATED_SLOT</TD></TR></TABLE> >];

IERC20Permit[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20Permit</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    permit(address,address,uint256,uint256,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    nonces(address)</TD></TR><TR><TD align="left">    DOMAIN_SEPARATOR()</TD></TR></TABLE> >];

IERC721Receiver[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC721Receiver</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    onERC721Received(address,address,uint256,bytes)</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResultFromTarget(address,bool,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR><TR><TD align="left">    _revert(bytes,string)</TD></TR></TABLE> >];

Checkpoints[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Checkpoints</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getAtBlock(Checkpoints.History,uint256)</TD></TR><TR><TD align="left">    getAtProbablyRecentBlock(Checkpoints.History,uint256)</TD></TR><TR><TD align="left">    push(Checkpoints.History,uint256)</TD></TR><TR><TD align="left">    push(Checkpoints.History,function(uint256,uint256) returns(uint256),uint256)</TD></TR><TR><TD align="left">    latest(Checkpoints.History)</TD></TR><TR><TD align="left">    latestCheckpoint(Checkpoints.History)</TD></TR><TR><TD align="left">    length(Checkpoints.History)</TD></TR><TR><TD align="left">    _insert(Checkpoints.Checkpoint[],uint32,uint224)</TD></TR><TR><TD align="left">    _upperBinaryLookup(Checkpoints.Checkpoint[],uint32,uint256,uint256)</TD></TR><TR><TD align="left">    _lowerBinaryLookup(Checkpoints.Checkpoint[],uint32,uint256,uint256)</TD></TR><TR><TD align="left">    _unsafeAccess(Checkpoints.Checkpoint[],uint256)</TD></TR><TR><TD align="left">    push(Checkpoints.Trace224,uint32,uint224)</TD></TR><TR><TD align="left">    lowerLookup(Checkpoints.Trace224,uint32)</TD></TR><TR><TD align="left">    upperLookup(Checkpoints.Trace224,uint32)</TD></TR><TR><TD align="left">    latest(Checkpoints.Trace224)</TD></TR><TR><TD align="left">    latestCheckpoint(Checkpoints.Trace224)</TD></TR><TR><TD align="left">    length(Checkpoints.Trace224)</TD></TR><TR><TD align="left">    _insert(Checkpoints.Checkpoint224[],uint32,uint224)</TD></TR><TR><TD align="left">    _upperBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256)</TD></TR><TR><TD align="left">    _lowerBinaryLookup(Checkpoints.Checkpoint224[],uint32,uint256,uint256)</TD></TR><TR><TD align="left">    _unsafeAccess(Checkpoints.Checkpoint224[],uint256)</TD></TR><TR><TD align="left">    push(Checkpoints.Trace160,uint96,uint160)</TD></TR><TR><TD align="left">    lowerLookup(Checkpoints.Trace160,uint96)</TD></TR><TR><TD align="left">    upperLookup(Checkpoints.Trace160,uint96)</TD></TR><TR><TD align="left">    latest(Checkpoints.Trace160)</TD></TR><TR><TD align="left">    latestCheckpoint(Checkpoints.Trace160)</TD></TR><TR><TD align="left">    length(Checkpoints.Trace160)</TD></TR><TR><TD align="left">    _insert(Checkpoints.Checkpoint160[],uint96,uint160)</TD></TR><TR><TD align="left">    _upperBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256)</TD></TR><TR><TD align="left">    _lowerBinaryLookup(Checkpoints.Checkpoint160[],uint96,uint256,uint256)</TD></TR><TR><TD align="left">    _unsafeAccess(Checkpoints.Checkpoint160[],uint256)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

Counters[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Counters</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    current(Counters.Counter)</TD></TR><TR><TD align="left">    increment(Counters.Counter)</TD></TR><TR><TD align="left">    decrement(Counters.Counter)</TD></TR><TR><TD align="left">    reset(Counters.Counter)</TD></TR></TABLE> >];

Strings[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Strings</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256)</TD></TR><TR><TD align="left">    toHexString(uint256,uint256)</TD></TR><TR><TD align="left">    toHexString(address)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _SYMBOLS</TD></TR><TR><TD align="left">    _ADDRESS_LENGTH</TD></TR></TABLE> >];

Timers[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Timers</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getDeadline(Timers.Timestamp)</TD></TR><TR><TD align="left">    setDeadline(Timers.Timestamp,uint64)</TD></TR><TR><TD align="left">    reset(Timers.Timestamp)</TD></TR><TR><TD align="left">    isUnset(Timers.Timestamp)</TD></TR><TR><TD align="left">    isStarted(Timers.Timestamp)</TD></TR><TR><TD align="left">    isPending(Timers.Timestamp)</TD></TR><TR><TD align="left">    isExpired(Timers.Timestamp)</TD></TR><TR><TD align="left">    getDeadline(Timers.BlockNumber)</TD></TR><TR><TD align="left">    setDeadline(Timers.BlockNumber,uint64)</TD></TR><TR><TD align="left">    reset(Timers.BlockNumber)</TD></TR><TR><TD align="left">    isUnset(Timers.BlockNumber)</TD></TR><TR><TD align="left">    isStarted(Timers.BlockNumber)</TD></TR><TR><TD align="left">    isPending(Timers.BlockNumber)</TD></TR><TR><TD align="left">    isExpired(Timers.BlockNumber)</TD></TR></TABLE> >];

ECDSA[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ECDSA</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _throwError(ECDSA.RecoverError)</TD></TR><TR><TD align="left">    tryRecover(bytes32,bytes)</TD></TR><TR><TD align="left">    recover(bytes32,bytes)</TD></TR><TR><TD align="left">    tryRecover(bytes32,bytes32,bytes32)</TD></TR><TR><TD align="left">    recover(bytes32,bytes32,bytes32)</TD></TR><TR><TD align="left">    tryRecover(bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    recover(bytes32,uint8,bytes32,bytes32)</TD></TR><TR><TD align="left">    toEthSignedMessageHash(bytes32)</TD></TR><TR><TD align="left">    toEthSignedMessageHash(bytes)</TD></TR><TR><TD align="left">    toTypedDataHash(bytes32,bytes32)</TD></TR></TABLE> >];

EIP712[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>EIP712</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _domainSeparatorV4()</TD></TR><TR><TD align="left">    _buildDomainSeparator(bytes32,bytes32,bytes32)</TD></TR><TR><TD align="left">    _hashTypedDataV4(bytes32)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _CACHED_DOMAIN_SEPARATOR</TD></TR><TR><TD align="left">    _CACHED_CHAIN_ID</TD></TR><TR><TD align="left">    _CACHED_THIS</TD></TR><TR><TD align="left">    _HASHED_NAME</TD></TR><TR><TD align="left">    _HASHED_VERSION</TD></TR><TR><TD align="left">    _TYPE_HASH</TD></TR></TABLE> >];

ERC165 -> IERC165;
ERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR></TABLE> >];

IERC165[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC165</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    supportsInterface(bytes4)</TD></TR></TABLE> >];

Math[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Math</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    max(uint256,uint256)</TD></TR><TR><TD align="left">    min(uint256,uint256)</TD></TR><TR><TD align="left">    average(uint256,uint256)</TD></TR><TR><TD align="left">    ceilDiv(uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256)</TD></TR><TR><TD align="left">    mulDiv(uint256,uint256,uint256,Math.Rounding)</TD></TR><TR><TD align="left">    sqrt(uint256)</TD></TR><TR><TD align="left">    sqrt(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log2(uint256)</TD></TR><TR><TD align="left">    log2(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log10(uint256)</TD></TR><TR><TD align="left">    log10(uint256,Math.Rounding)</TD></TR><TR><TD align="left">    log256(uint256)</TD></TR><TR><TD align="left">    log256(uint256,Math.Rounding)</TD></TR></TABLE> >];

SafeCast[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>SafeCast</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    toUint248(uint256)</TD></TR><TR><TD align="left">    toUint240(uint256)</TD></TR><TR><TD align="left">    toUint232(uint256)</TD></TR><TR><TD align="left">    toUint224(uint256)</TD></TR><TR><TD align="left">    toUint216(uint256)</TD></TR><TR><TD align="left">    toUint208(uint256)</TD></TR><TR><TD align="left">    toUint200(uint256)</TD></TR><TR><TD align="left">    toUint192(uint256)</TD></TR><TR><TD align="left">    toUint184(uint256)</TD></TR><TR><TD align="left">    toUint176(uint256)</TD></TR><TR><TD align="left">    toUint168(uint256)</TD></TR><TR><TD align="left">    toUint160(uint256)</TD></TR><TR><TD align="left">    toUint152(uint256)</TD></TR><TR><TD align="left">    toUint144(uint256)</TD></TR><TR><TD align="left">    toUint136(uint256)</TD></TR><TR><TD align="left">    toUint128(uint256)</TD></TR><TR><TD align="left">    toUint120(uint256)</TD></TR><TR><TD align="left">    toUint112(uint256)</TD></TR><TR><TD align="left">    toUint104(uint256)</TD></TR><TR><TD align="left">    toUint96(uint256)</TD></TR><TR><TD align="left">    toUint88(uint256)</TD></TR><TR><TD align="left">    toUint80(uint256)</TD></TR><TR><TD align="left">    toUint72(uint256)</TD></TR><TR><TD align="left">    toUint64(uint256)</TD></TR><TR><TD align="left">    toUint56(uint256)</TD></TR><TR><TD align="left">    toUint48(uint256)</TD></TR><TR><TD align="left">    toUint40(uint256)</TD></TR><TR><TD align="left">    toUint32(uint256)</TD></TR><TR><TD align="left">    toUint24(uint256)</TD></TR><TR><TD align="left">    toUint16(uint256)</TD></TR><TR><TD align="left">    toUint8(uint256)</TD></TR><TR><TD align="left">    toUint256(int256)</TD></TR><TR><TD align="left">    toInt248(int256)</TD></TR><TR><TD align="left">    toInt240(int256)</TD></TR><TR><TD align="left">    toInt232(int256)</TD></TR><TR><TD align="left">    toInt224(int256)</TD></TR><TR><TD align="left">    toInt216(int256)</TD></TR><TR><TD align="left">    toInt208(int256)</TD></TR><TR><TD align="left">    toInt200(int256)</TD></TR><TR><TD align="left">    toInt192(int256)</TD></TR><TR><TD align="left">    toInt184(int256)</TD></TR><TR><TD align="left">    toInt176(int256)</TD></TR><TR><TD align="left">    toInt168(int256)</TD></TR><TR><TD align="left">    toInt160(int256)</TD></TR><TR><TD align="left">    toInt152(int256)</TD></TR><TR><TD align="left">    toInt144(int256)</TD></TR><TR><TD align="left">    toInt136(int256)</TD></TR><TR><TD align="left">    toInt128(int256)</TD></TR><TR><TD align="left">    toInt120(int256)</TD></TR><TR><TD align="left">    toInt112(int256)</TD></TR><TR><TD align="left">    toInt104(int256)</TD></TR><TR><TD align="left">    toInt96(int256)</TD></TR><TR><TD align="left">    toInt88(int256)</TD></TR><TR><TD align="left">    toInt80(int256)</TD></TR><TR><TD align="left">    toInt72(int256)</TD></TR><TR><TD align="left">    toInt64(int256)</TD></TR><TR><TD align="left">    toInt56(int256)</TD></TR><TR><TD align="left">    toInt48(int256)</TD></TR><TR><TD align="left">    toInt40(int256)</TD></TR><TR><TD align="left">    toInt32(int256)</TD></TR><TR><TD align="left">    toInt24(int256)</TD></TR><TR><TD align="left">    toInt16(int256)</TD></TR><TR><TD align="left">    toInt8(int256)</TD></TR><TR><TD align="left">    toInt256(uint256)</TD></TR></TABLE> >];

DoubleEndedQueue[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>DoubleEndedQueue</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    pushBack(DoubleEndedQueue.Bytes32Deque,bytes32)</TD></TR><TR><TD align="left">    popBack(DoubleEndedQueue.Bytes32Deque)</TD></TR><TR><TD align="left">    pushFront(DoubleEndedQueue.Bytes32Deque,bytes32)</TD></TR><TR><TD align="left">    popFront(DoubleEndedQueue.Bytes32Deque)</TD></TR><TR><TD align="left">    front(DoubleEndedQueue.Bytes32Deque)</TD></TR><TR><TD align="left">    back(DoubleEndedQueue.Bytes32Deque)</TD></TR><TR><TD align="left">    at(DoubleEndedQueue.Bytes32Deque,uint256)</TD></TR><TR><TD align="left">    clear(DoubleEndedQueue.Bytes32Deque)</TD></TR><TR><TD align="left">    length(DoubleEndedQueue.Bytes32Deque)</TD></TR><TR><TD align="left">    empty(DoubleEndedQueue.Bytes32Deque)</TD></TR></TABLE> >];

Box -> Ownable;
Box[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Box</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    store(uint256)</TD></TR><TR><TD align="left">    retrieve()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    value</TD></TR></TABLE> >];

GovernanceToken -> ERC20Votes;
GovernanceToken[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernanceToken</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _afterTokenTransfer(address,address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _mint(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _burn(address,uint256)</font></TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    s_maxSupply</TD></TR></TABLE> >];

GovernorContract -> Governor [ label="1" ];
GovernorContract -> GovernorSettings [ label="2" ];
GovernorContract -> GovernorCountingSimple [ label="3" ];
GovernorContract -> GovernorVotes [ label="4" ];
GovernorContract -> GovernorVotesQuorumFraction [ label="5" ];
GovernorContract -> GovernorTimelockControl [ label="6" ];
GovernorContract[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>GovernorContract</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    votingDelay()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    votingPeriod()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    quorum(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getVotes(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    state(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    propose(address[],uint256[],bytes[],string)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    proposalThreshold()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    supportsInterface(bytes4)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    _execute(uint256,address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _cancel(address[],uint256[],bytes[],bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    _executor()</font></TD></TR><TR><TD><BR/></TD></TR><TR><TD align="left" border="1"><font color="#777777" point-size="10">'COUNTING_MODE()' collides in inherited contracts IGovernor, IGovernor, IGovernor, IGovernor, IGovernor, GovernorCountingSimple where GovernorCountingSimple is chosen.<BR/>'hasVoted(uint256,address)' collides in inherited contracts IGovernor, IGovernor, IGovernor, IGovernor, IGovernor, GovernorCountingSimple where GovernorCountingSimple is chosen.<BR/>'_quorumReached(uint256)' collides in inherited contracts Governor, Governor, Governor, Governor, Governor, GovernorCountingSimple where GovernorCountingSimple is chosen.<BR/>'_voteSucceeded(uint256)' collides in inherited contracts Governor, Governor, Governor, Governor, Governor, GovernorCountingSimple where GovernorCountingSimple is chosen.<BR/>'_getVotes(address,uint256,bytes)' collides in inherited contracts Governor, Governor, Governor, Governor, GovernorVotes where GovernorVotes is chosen.<BR/>'_countVote(uint256,address,uint8,uint256,bytes)' collides in inherited contracts Governor, Governor, Governor, Governor, Governor, GovernorCountingSimple where GovernorCountingSimple is chosen.</font></TD></TR></TABLE> >];

TimeLock -> TimelockController;
TimeLock[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>TimeLock</B></TD></TR></TABLE> >];

}